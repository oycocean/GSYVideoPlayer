diff --git a/libavformat/Makefile b/libavformat/Makefile
index 0658fa3710..7ceb0b1895 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -4,6 +4,14 @@ DESC = FFmpeg container format library
 HEADERS = avformat.h                                                    \
           avio.h                                                        \
           version.h                                                     \
+          avc.h                                                         \
+          url.h                                                         \
+          internal.h                                                    \
+          avio_internal.h                                               \
+          flv.h                                                         \
+          id3v2.h                                                       \
+          os_support.h                                                  \
+          metadata.h                                                  \
 
 OBJS = allformats.o         \
        avio.o               \
@@ -23,6 +31,8 @@ OBJS = allformats.o         \
        sdp.o                \
        url.o                \
        utils.o              \
+       avc.o                \
+       ijkutils.o           \
 
 OBJS-$(HAVE_LIBC_MSVCRT)                 += file_open.o
 
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index a7c5c9db89..82880bc027 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -473,6 +473,8 @@ extern AVInputFormat  ff_xwma_demuxer;
 extern AVInputFormat  ff_yop_demuxer;
 extern AVInputFormat  ff_yuv4mpegpipe_demuxer;
 extern AVOutputFormat ff_yuv4mpegpipe_muxer;
+extern AVInputFormat  ff_ijklivehook_demuxer;
+extern AVInputFormat  ff_ijklas_demuxer;
 /* image demuxers */
 extern AVInputFormat  ff_image_bmp_pipe_demuxer;
 extern AVInputFormat  ff_image_dds_pipe_demuxer;
diff --git a/libavformat/concatdec.c b/libavformat/concatdec.c
index 4b56b61404..b12ad3ec9a 100644
--- a/libavformat/concatdec.c
+++ b/libavformat/concatdec.c
@@ -330,6 +330,7 @@ static int open_file(AVFormatContext *avf, unsigned fileno)
     ConcatContext *cat = avf->priv_data;
     ConcatFile *file = &cat->files[fileno];
     int ret;
+    AVDictionary *tmp = NULL;
 
     if (cat->avf)
         avformat_close_input(&cat->avf);
@@ -343,9 +344,10 @@ static int open_file(AVFormatContext *avf, unsigned fileno)
 
     if ((ret = ff_copy_whiteblacklists(cat->avf, avf)) < 0)
         return ret;
-
-    if ((ret = avformat_open_input(&cat->avf, file->url, NULL, NULL)) < 0 ||
-        (ret = avformat_find_stream_info(cat->avf, NULL)) < 0) {
+    av_dict_set_int(&tmp, "cur_file_no", fileno, 0);
+    ret = avformat_open_input(&cat->avf, file->url, NULL, &tmp);
+    av_dict_free(&tmp);
+    if (ret < 0 || (ret = avformat_find_stream_info(cat->avf, NULL)) < 0) {
         av_log(avf, AV_LOG_ERROR, "Impossible to open '%s'\n", file->url);
         avformat_close_input(&cat->avf);
         return ret;
diff --git a/libavformat/ijkutils.c b/libavformat/ijkutils.c
new file mode 100644
index 0000000000..6074743023
--- /dev/null
+++ b/libavformat/ijkutils.c
@@ -0,0 +1,118 @@
+/*
+ * utils.c
+ *
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) 2013 Zhang Rui <bbcallen@gmail.com>
+ *
+ * This file is part of ijkPlayer.
+ *
+ * ijkPlayer is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * ijkPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with ijkPlayer; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdlib.h>
+#include "url.h"
+#include "avformat.h"
+
+
+#define IJK_FF_PROTOCOL(x)                                                                          \
+extern URLProtocol ff_##x##_protocol;                                                               \
+int ijkav_register_##x##_protocol(URLProtocol *protocol, int protocol_size);                        \
+int ijkav_register_##x##_protocol(URLProtocol *protocol, int protocol_size)                         \
+{                                                                                                   \
+    if (protocol_size != sizeof(URLProtocol)) {                                                     \
+        av_log(NULL, AV_LOG_ERROR, "ijkav_register_##x##_protocol: ABI mismatch.\n");               \
+        return -1;                                                                                  \
+    }                                                                                               \
+    memcpy(&ff_##x##_protocol, protocol, protocol_size);                                            \
+    return 0;                                                                                       \
+}
+
+#define IJK_DUMMY_PROTOCOL(x)                                       \
+IJK_FF_PROTOCOL(x);                                                 \
+static const AVClass ijk_##x##_context_class = {                    \
+    .class_name = #x,                                               \
+    .item_name  = av_default_item_name,                             \
+    .version    = LIBAVUTIL_VERSION_INT,                            \
+    };                                                              \
+                                                                    \
+URLProtocol ff_##x##_protocol = {                                   \
+    .name                = #x,                                      \
+    .url_open2           = ijkdummy_open,                           \
+    .priv_data_size      = 1,                                       \
+    .priv_data_class     = &ijk_##x##_context_class,                \
+};
+
+static int ijkdummy_open(URLContext *h, const char *arg, int flags, AVDictionary **options)
+{
+    return -1;
+}
+
+int ijkav_register_async_protocol(URLProtocol *protocol, int protocol_size);
+int ijkav_register_async_protocol(URLProtocol *protocol, int protocol_size)
+{
+    if (protocol_size != sizeof(URLProtocol)) {
+        av_log(NULL, AV_LOG_ERROR, "ijkav_register_async_protocol: ABI mismatch.\n");
+        return -1;
+    }
+
+    /*
+     * On FFmpeg n4.3 the built-in ff_async_protocol lives in read-only memory.
+     * Legacy ijk flow memcpy() overwrote it at runtime, which crashes with
+     * SEGV_ACCERR on Android 16KB-page binaries.
+     *
+     * Keep the registration call as a compatibility no-op and continue with the
+     * built-in async protocol implementation.
+     */
+    av_log(NULL, AV_LOG_WARNING,
+           "ijkav_register_async_protocol: skip overriding built-in async protocol on n4.3\n");
+    (void)protocol;
+    return 0;
+}
+IJK_DUMMY_PROTOCOL(ijkmediadatasource);
+IJK_DUMMY_PROTOCOL(ijkhttphook);
+IJK_DUMMY_PROTOCOL(ijklongurl);
+IJK_DUMMY_PROTOCOL(ijksegment);
+IJK_DUMMY_PROTOCOL(ijktcphook);
+IJK_DUMMY_PROTOCOL(ijkio);
+
+#define IJK_FF_DEMUXER(x)                                                                          \
+extern AVInputFormat ff_##x##_demuxer;                                                               \
+int ijkav_register_##x##_demuxer(AVInputFormat *demuxer, int demuxer_size);                        \
+int ijkav_register_##x##_demuxer(AVInputFormat *demuxer, int demuxer_size)                         \
+{                                                                                                   \
+    if (demuxer_size != sizeof(AVInputFormat)) {                                                     \
+        av_log(NULL, AV_LOG_ERROR, "ijkav_register_##x##_demuxer: ABI mismatch.\n");               \
+        return -1;                                                                                  \
+    }                                                                                               \
+    memcpy(&ff_##x##_demuxer, demuxer, demuxer_size);                                            \
+    return 0;                                                                                       \
+}
+
+#define IJK_DUMMY_DEMUXER(x)                                        \
+IJK_FF_DEMUXER(x);                                                  \
+static const AVClass ijk_##x##_demuxer_class = {                    \
+    .class_name = #x,                                               \
+    .item_name  = av_default_item_name,                             \
+    .version    = LIBAVUTIL_VERSION_INT,                            \
+    };                                                              \
+                                                                    \
+AVInputFormat ff_##x##_demuxer = {                                  \
+    .name                = #x,                                      \
+    .priv_data_size      = 1,                                       \
+    .priv_class          = &ijk_##x##_demuxer_class,                \
+};
+
+IJK_DUMMY_DEMUXER(ijklivehook);
+IJK_DUMMY_DEMUXER(ijklas);
diff --git a/libavformat/protocols.c b/libavformat/protocols.c
index f1b8eab0fd..9627492b45 100644
--- a/libavformat/protocols.c
+++ b/libavformat/protocols.c
@@ -39,6 +39,12 @@ extern const URLProtocol ff_http_protocol;
 extern const URLProtocol ff_httpproxy_protocol;
 extern const URLProtocol ff_https_protocol;
 extern const URLProtocol ff_icecast_protocol;
+extern const URLProtocol ff_ijkhttphook_protocol;
+extern const URLProtocol ff_ijklongurl_protocol;
+extern const URLProtocol ff_ijkmediadatasource_protocol;
+extern const URLProtocol ff_ijksegment_protocol;
+extern const URLProtocol ff_ijktcphook_protocol;
+extern const URLProtocol ff_ijkio_protocol;
 extern const URLProtocol ff_mmsh_protocol;
 extern const URLProtocol ff_mmst_protocol;
 extern const URLProtocol ff_md5_protocol;
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 9b08372eb2..8579cf0435 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -4,6 +4,7 @@ DESC = FFmpeg utility library
 HEADERS = adler32.h                                                     \
           aes.h                                                         \
           aes_ctr.h                                                     \
+          application.h                                                 \
           attributes.h                                                  \
           audio_fifo.h                                                  \
           avassert.h                                                    \
@@ -98,6 +99,7 @@ BUILT_HEADERS = avconfig.h                                              \
 OBJS = adler32.o                                                        \
        aes.o                                                            \
        aes_ctr.o                                                        \
+       application.o                                                    \
        audio_fifo.o                                                     \
        avstring.o                                                       \
        avsscanf.o                                                       \
diff --git a/libavutil/application.c b/libavutil/application.c
new file mode 100644
index 0000000000..a503cbfa9a
--- /dev/null
+++ b/libavutil/application.c
@@ -0,0 +1,215 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "application.h"
+#include "libavformat/network.h"
+#include "libavutil/avstring.h"
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event);
+
+int av_application_alloc(AVApplicationContext **ph, void *opaque)
+{
+    AVApplicationContext *h = NULL;
+
+    h = av_mallocz(sizeof(AVApplicationContext));
+    if (!h)
+        return AVERROR(ENOMEM);
+
+    h->opaque = opaque;
+
+    *ph = h;
+    return 0;
+}
+
+int av_application_open(AVApplicationContext **ph, void *opaque)
+{
+    int ret = av_application_alloc(ph, opaque);
+    if (ret)
+        return ret;
+
+    return 0;
+}
+
+void av_application_close(AVApplicationContext *h)
+{
+    av_free(h);
+}
+
+void av_application_closep(AVApplicationContext **ph)
+{
+    if (!ph || !*ph)
+        return;
+
+    av_application_close(*ph);
+    *ph = NULL;
+}
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, event_type, (void *)event, sizeof(AVAppHttpEvent));
+}
+
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_OPEN, &event);
+}
+
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+    event.filesize  = filesize;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_OPEN, &event);
+}
+
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_SEEK, &event);
+}
+
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_SEEK, &event);
+}
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_IO_TRAFFIC, (void *)event, sizeof(AVAppIOTraffic));
+}
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control)
+{
+    if (h && h->func_on_app_event)
+        return h->func_on_app_event(h, event_type, (void *)control, sizeof(AVAppIOControl));
+    return 0;
+}
+
+int av_application_on_tcp_will_open(AVApplicationContext *h)
+{
+    if (h && h->func_on_app_event) {
+        AVAppTcpIOControl control = {0};
+        return h->func_on_app_event(h, AVAPP_CTRL_WILL_TCP_OPEN, (void *)&control, sizeof(AVAppTcpIOControl));
+    }
+    return 0;
+}
+
+// only callback returns error
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd)
+{
+    struct sockaddr_storage so_stg;
+    int       ret = 0;
+    socklen_t so_len = sizeof(so_stg);
+    int       so_family;
+    AVAppTcpIOControl control = {0};
+    char      *so_ip_name = control.ip;
+
+    if (!h || !h->func_on_app_event || fd <= 0)
+        return 0;
+
+    ret = getpeername(fd, (struct sockaddr *)&so_stg, &so_len);
+    if (ret)
+        return 0;
+    control.error = error;
+    control.fd = fd;
+
+    so_family = ((struct sockaddr*)&so_stg)->sa_family;
+    switch (so_family) {
+        case AF_INET: {
+            struct sockaddr_in* in4 = (struct sockaddr_in*)&so_stg;
+            if (inet_ntop(AF_INET, &(in4->sin_addr), so_ip_name, sizeof(control.ip))) {
+                control.family = AF_INET;
+                control.port = in4->sin_port;
+            }
+            break;
+        }
+        case AF_INET6: {
+            struct sockaddr_in6* in6 = (struct sockaddr_in6*)&so_stg;
+            if (inet_ntop(AF_INET6, &(in6->sin6_addr), so_ip_name, sizeof(control.ip))) {
+                control.family = AF_INET6;
+                control.port = in6->sin6_port;
+            }
+            break;
+        }
+    }
+
+    return h->func_on_app_event(h, AVAPP_CTRL_DID_TCP_OPEN, (void *)&control, sizeof(AVAppTcpIOControl));
+}
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_STATISTIC, (void *)statistic, sizeof(AVAppAsyncStatistic));
+}
+
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_READ_SPEED, (void *)speed, sizeof(AVAppAsyncReadSpeed));
+}
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes)
+{
+    AVAppIOTraffic event = {0};
+    if (!h || !obj || bytes <= 0)
+        return;
+
+    event.obj        = obj;
+    event.bytes      = bytes;
+
+    av_application_on_io_traffic(h, &event);
+}
diff --git a/libavutil/application.h b/libavutil/application.h
new file mode 100644
index 0000000000..e760dfae23
--- /dev/null
+++ b/libavutil/application.h
@@ -0,0 +1,121 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_APPLICATION_H
+#define AVUTIL_APPLICATION_H
+
+#include "libavutil/log.h"
+
+#define AVAPP_EVENT_WILL_HTTP_OPEN  1 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_OPEN   2 //AVAppHttpEvent
+#define AVAPP_EVENT_WILL_HTTP_SEEK  3 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_SEEK   4 //AVAppHttpEvent
+
+#define AVAPP_EVENT_ASYNC_STATISTIC     0x11000 //AVAppAsyncStatistic
+#define AVAPP_EVENT_ASYNC_READ_SPEED    0x11001 //AVAppAsyncReadSpeed
+#define AVAPP_EVENT_IO_TRAFFIC          0x12204 //AVAppIOTraffic
+
+#define AVAPP_CTRL_WILL_TCP_OPEN   0x20001 //AVAppTcpIOControl
+#define AVAPP_CTRL_DID_TCP_OPEN    0x20002 //AVAppTcpIOControl
+
+#define AVAPP_CTRL_WILL_HTTP_OPEN  0x20003 //AVAppIOControl
+#define AVAPP_CTRL_WILL_LIVE_OPEN  0x20005 //AVAppIOControl
+
+#define AVAPP_CTRL_WILL_CONCAT_SEGMENT_OPEN 0x20007 //AVAppIOControl
+
+typedef struct AVAppIOControl {
+    size_t  size;
+    char    url[4096];      /* in, out */
+    int     segment_index;  /* in, default = 0 */
+    int     retry_counter;  /* in */
+
+    int     is_handled;     /* out, default = false */
+    int     is_url_changed; /* out, default = false */
+} AVAppIOControl;
+
+typedef struct AVAppTcpIOControl {
+    int  error;
+    int  family;
+    char ip[96];
+    int  port;
+    int  fd;
+} AVAppTcpIOControl;
+
+typedef struct AVAppAsyncStatistic {
+    size_t  size;
+    int64_t buf_backwards;
+    int64_t buf_forwards;
+    int64_t buf_capacity;
+} AVAppAsyncStatistic;
+
+typedef struct AVAppAsyncReadSpeed {
+    size_t  size;
+    int     is_full_speed;
+    int64_t io_bytes;
+    int64_t elapsed_milli;
+} AVAppAsyncReadSpeed;
+
+typedef struct AVAppHttpEvent
+{
+    void    *obj;
+    char     url[4096];
+    int64_t  offset;
+    int      error;
+    int      http_code;
+    int64_t  filesize;
+} AVAppHttpEvent;
+
+typedef struct AVAppIOTraffic
+{
+    void   *obj;
+    int     bytes;
+} AVAppIOTraffic;
+
+typedef struct AVApplicationContext AVApplicationContext;
+struct AVApplicationContext {
+    const AVClass *av_class;    /**< information for av_log(). Set by av_application_open(). */
+    void *opaque;               /**< user data. */
+
+    int (*func_on_app_event)(AVApplicationContext *h, int event_type ,void *obj, size_t size);
+};
+
+int  av_application_alloc(AVApplicationContext **ph, void *opaque);
+int  av_application_open(AVApplicationContext **ph, void *opaque);
+void av_application_close(AVApplicationContext *h);
+void av_application_closep(AVApplicationContext **ph);
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event);
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url);
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize);
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset);
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code);
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes);
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control);
+
+int av_application_on_tcp_will_open(AVApplicationContext *h);
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd);
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic);
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed);
+
+
+#endif /* AVUTIL_APPLICATION_H */
diff --git a/libavutil/dict.c b/libavutil/dict.c
index 9d3d96c58b..985208889b 100644
--- a/libavutil/dict.c
+++ b/libavutil/dict.c
@@ -153,6 +153,43 @@ int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value,
     return av_dict_set(pm, key, valuestr, flags);
 }
 
+int av_dict_set_intptr(AVDictionary **pm, const char *key, uintptr_t value,
+                int flags)
+{
+    char valuestr[22];
+    snprintf(valuestr, sizeof(valuestr), "%p", value);
+    flags &= ~AV_DICT_DONT_STRDUP_VAL;
+    return av_dict_set(pm, key, valuestr, flags);
+}
+
+uintptr_t av_dict_get_intptr(const AVDictionary *m, const char* key) {
+    uintptr_t ptr = NULL;
+    AVDictionaryEntry *t = NULL;
+    if ((t = av_dict_get(m, key, NULL, 0))) {
+      return av_dict_strtoptr(t->value);
+    }
+    return NULL;
+}
+
+uintptr_t av_dict_strtoptr(char * value) {
+   uintptr_t ptr = NULL;
+   char *next = NULL;
+   if(!value || value[0] !='0' || (value[1]|0x20)!='x') {
+       return NULL;
+   }
+   ptr = strtoull(value, &next, 16);
+   if (next == value) {
+       return NULL;
+   }
+   return ptr;
+}
+
+char * av_dict_ptrtostr(uintptr_t value) {
+    char valuestr[22] = {0};
+    snprintf(valuestr, sizeof(valuestr), "%p", value);
+    return av_strdup(valuestr);
+}
+
 static int parse_key_value_pair(AVDictionary **pm, const char **buf,
                                 const char *key_val_sep, const char *pairs_sep,
                                 int flags)
diff --git a/libavutil/dict.h b/libavutil/dict.h
index 118f1f00ed..9d6d8dfdfe 100644
--- a/libavutil/dict.h
+++ b/libavutil/dict.h
@@ -137,6 +137,16 @@ int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags
  */
 int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags);
 
+/**
+ * Convenience wrapper for av_dict_get that converts the value to a pointer
+ * and stores it.
+ *
+ */
+int av_dict_set_intptr(AVDictionary **pm, const char *key, uintptr_t value, int flags);
+uintptr_t av_dict_get_intptr(const AVDictionary *m, const char* key);
+uintptr_t av_dict_strtoptr(char * value);
+char * av_dict_ptrtostr(uintptr_t value);
+
 /**
  * Parse the key/value pairs list and add the parsed entries to a dictionary.
  *
